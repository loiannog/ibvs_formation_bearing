#include "imgproc.h"
#include <cstdio>
// Set dot characteristics for the auto detection

bool points_init = false;
//#define GUI
  vpDisplayOpenCV d;
  vpMeNurbs tracking_rect;
  vpMe me;
  vpDot2 tracker_rectangle[1];
// any pixel value lower than threshold1 becomes black.  I think threshold2 just needs to be > 1.  JT
  double pitch;
  bool semaphore_imu = true;
  void getCylinderPosition::imu_callback(const geometry_msgs::Vector3& imu_msg)
  {
	  while(semaphore_imu==false) usleep(10);
		  semaphore_imu=false;
		  pitch = imu_msg.x;
		  semaphore_imu = true;

  }

Patch imgproc(const Mat &src, getCylinderPosition* obj_ptr)
{
  Mat blurred, thresholded, reduced;
  int threshold1 = obj_ptr->image_threshold;
  //GaussianBlur(src, blurred, Size(3,3), 0);//clean the image
  //threshold(src, thresholded, threshold1, 255, THRESH_BINARY_INV);//threshold the image
  threshold(src, thresholded, threshold1, 255, THRESH_TOZERO);//threshold the image
  vpImage<unsigned char> I;
imshow("thresholded", thresholded);
waitKey(2);
  vpImageConvert::convert(thresholded, I);

  tracker_rectangle[0].setComputeMoments(1);
  d.init(I, 0, 0, "") ;

  vpDisplay::display(I);

  if (points_init == false){
	  d.init(I, 0, 0, "") ;

	  vpDisplay::display(I);
	  std::list<vpDot2> list_d;//list of elements in constrast respect ot the background
	  vpDot2 dot_search;

	  dot_search.setGraphics(true);

	  //dot_search.setSurface(obj_ptr->Surface);
	  dot_search.setGrayLevelMin(obj_ptr->GrayLevelMin);
	  dot_search.setGrayLevelMax(obj_ptr->GrayLevelMax);
	  dot_search.setGrayLevelPrecision(obj_ptr->opt_grayLevelPrecision);
	  dot_search.setSizePrecision(obj_ptr->opt_sizePrecision);
	  dot_search.setEllipsoidShapePrecision(obj_ptr->opt_ellipsoidShapePrecision);
	  try
	   {
		  while(list_d.size() == 0){
		  dot_search.searchDotsInArea(I, obj_ptr->width_min,  obj_ptr->height_min,  obj_ptr->width_max, obj_ptr->height_max, list_d) ;
		  cout<<"searching the first dot"<<endl;
		  }
		  //dot_search.searchDotsInArea(I, list_d);
	   }
	  catch (int e)
	   {
	     cout << "An exception occurred. Exception Nr. " << e << endl;
	   }
	  vpImagePoint init_point;
	  cout<<"size"<<list_d.size()<<endl;
	  if(list_d.size()!=0){
	  init_point.set_i(list_d.front().getCog().get_i());
	  init_point.set_j(list_d.front().getCog().get_j());
	  tracker_rectangle[0].initTracking(I,init_point);
	  }
	  else{
		  cout<<"no regions have been found select it on the image"<<endl;
	  }
	  try
	   {
        tracker_rectangle[0].track(I);
	   }
  	  catch (const std::exception &e)
  	   {
  		  cout<<" tracking failed start to send vicon message recovery"<<endl;
  		  while(ros::ok()){
  			  geometry_msgs::Vector3Stamped pos;
  			   pos.vector.z = ros::Time::now().toSec();
  			   pos.vector.x = 1000; // x1 point start (highest point)
  			   pos.vector.y = 1000; // x2 point (lowest point)
  			   obj_ptr->cylinder_pos_pub_.publish(pos);
  		  }
  	 }
	  tracker_rectangle[0].display(I, vpColor::red);
	  points_init = true;

  }
else{
	d.init(I, 0, 0, "") ;
	vpDisplay::display(I);
	  try
	   {
        tracker_rectangle[0].track(I);
	   }
  	  catch (const std::exception &e)
  	   {
  		  cout<<" tracking failed start to send vicon message recovery"<<endl;
  		  while(ros::ok()){
  			  geometry_msgs::Vector3Stamped pos;
  			   pos.vector.z = ros::Time::now().toSec();
  			   pos.vector.x = 1000; // x1 point start (highest point)
  			   pos.vector.y = 1000; // x2 point (lowest point)
  			   obj_ptr->cylinder_pos_pub_.publish(pos);
  		  }
  	   }
    tracker_rectangle[0].display(I, vpColor::red);
}
  Patch patch;
  double rectangle_width = tracker_rectangle[0].getWidth();
  double rectangle_height = tracker_rectangle[0].getHeight();
  cout<<"width"<<tracker_rectangle[0].getWidth()<<" "<<"height"<<tracker_rectangle[0].getHeight()<<endl;
  double rectangle_center_u = tracker_rectangle[0].getCog().get_i();
  double rectangle_center_v = tracker_rectangle[0].getCog().get_j();
  double alpha = 0.5*atan(2*tracker_rectangle[0].mu11/(tracker_rectangle[0].mu02-tracker_rectangle[0].mu20));
  patch.x1 = rectangle_center_v + rectangle_width/2;// - rectangle_width/2*cos(pi/2-alpha);
  patch.y1 = rectangle_center_u;//- rectangle_width/2*sin(pi/2-alpha);;
  patch.x2 = rectangle_center_v - rectangle_width/2;// + rectangle_width/2*cos(pi/2-alpha);
  patch.y2 = rectangle_center_u;// + rectangle_width/2*sin(pi/2-alpha);
  patch.orientation = alpha;
cout<<"rectangle_center_u"<<tracker_rectangle[0].getCog().get_i()<<"rectangle_center_v"<<tracker_rectangle[0].getCog().get_j()<<endl;
//matrix of points
vector<Point2f> P;
P.resize(2);
P[0].x = patch.x1;
P[0].y = patch.y1;
P[1].x = patch.x2;
P[1].y = patch.y2;
//undistort point
vector<Point2f> dst_P;
dst_P.resize(2);
const cv:: Mat cM = (cv::Mat_<double>(3,3) << obj_ptr->fx, 0.0, obj_ptr->cx, 0.0, obj_ptr->fy, obj_ptr->cy, 0.0, 0.0, 1.0);
const cv:: Mat Dl = (cv::Mat_<double>(4,1) << obj_ptr->d0, obj_ptr->d1, obj_ptr->d2, obj_ptr->d3);
undistortPoints(P, dst_P, cM, Dl);

//recompute patch to allign in the normalized plane
double gamma1 = atan(dst_P[0].x/cM.at<double>(0,2));
double gamma2 = atan(dst_P[1].x/cM.at<double>(0,2));
while(semaphore_imu==false) usleep(10);
semaphore_imu=false;
double theta = pitch;
semaphore_imu = true;
patch.x1 = cM.at<double>(0,2)*tan(theta+gamma1);
patch.x2 = cM.at<double>(0,2)*tan(theta+gamma2);
vpDisplay::flush(I);
//cout<<"dst_P11:"<<patch.x1 <<" "<<"dst_P12:"<<patch.x2<<endl;
patch.y1= ros::Time::now().toSec();
#ifdef GUI
  //imshow("Original image", src);
  //imshow("Blurred", blurred);
  //imshow("Threshold", thresholded);
  //imshow("Reduced", reduced);
  //cv::waitKey(1);
#endif

  return patch;
}
